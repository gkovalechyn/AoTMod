//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.18444
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Threading;

public class LagController {
	private List<PhotonPlayer> targets = new List<PhotonPlayer>(8);

	private LagMode mode;

	private Thread[] threads;
	private int interval;

	private volatile int burst = 5;

	public volatile bool isRunning = false;
	private volatile bool toStop = false;
	//Control variables, do not mess with.
	private object threadEndLock = new object();
	private object intervalLock = new object();
	private int threadEndAmount = 0;

	public LagController () {
		this.setThreadCount(1);
		this.setInterval(100);
		this.setMode(LagMode.OTHERS);
		this.setBurstAmount(5);
	}

	public void start(){
		this.threadEndAmount = 0;

		for(int i = 0; i < this.threads.Length; i++){
			threads[i] = new Thread(() => {this.threadRunMethod(i);});
			threads[i].Start();
		}
	}

	public bool addPlayer(int id){
		PhotonPlayer pt = PhotonPlayer.Find(id);
		if (pt != null){
			lock(this.targets){
				this.targets.Add(pt);
			}

			return true;
		}

		return false;
	}

	public void removeAt(int index){
		lock(this.targets){
			this.targets.RemoveAt(index);
		}
	}

	public List<PhotonPlayer> getTargets(){
		return this.targets;
	}

	public void setMode(LagMode mode){
		this.mode = mode;
	}

	public LagMode getMode(){
		return this.mode;
	}

	public void setThreadCount(int amount){
		this.threads = new Thread[amount];
	}

	public int getThreadCount(){
		return this.threads.Length;
	}

	private void threadRunMethod(int thread){
		//don't need to lock this
		this.isRunning = true;
		int amount;
		ModMain.instance.debug("Thread " + thread + " started.");
        FengGameManagerMKII gm = ModMain.instance.getGameManager();
		try{
            object[] o = new object[0];
			while(!this.toStop && PhotonNetwork.inRoom){
				amount = this.burst;
				switch(mode){
					case LagMode.ALL:
						for(int i = 0; i < amount; i++){
							gm.photonView.RPC("0x40", PhotonTargets.All, o);
						}
						break;
					case LagMode.OTHERS:
						for(int i = 0; i < amount; i++){
                            gm.photonView.RPC("0x40", PhotonTargets.Others, o);
						}
						break;
					case LagMode.LIST:
						lock(this.targets){
							foreach(PhotonPlayer player in this.targets){
								if (PhotonPlayer.Find(player.ID) == null){
#if DEBUG
									ModMain.instance.debug("Removing player : " + player);
#endif
									this.targets.Remove(player);
									continue;
								}

								for(int i = 0; i < amount; i++){
                                    gm.photonView.RPC("0x40", player, o);
								}
							}
						}
						break;
				}
			Thread.Sleep(this.interval);
		}
	}catch(System.Exception e){
		ModMain.instance.debug("Thread " + thread + " crashed.");
		ModMain.instance.log(e);
	}

		lock(this.threadEndLock){
#if DEBUG
			ModMain.instance.debug("LagController::Thread- Thread " + thread + " ended");
#endif
			this.threadEndAmount++;

			if (this.threadEndAmount == this.getThreadCount()){
#if DEBUG
				ModMain.instance.debug("LagController::Thread- Clearing threads. " + thread);
#endif
				this.isRunning = false;
				this.toStop = false;
				Array.Clear(this.threads, 0, this.threads.Length);
				this.targets.Clear();
			}
		}

	}

	public void setInterval(int interval){
		lock(this.intervalLock){
			this.interval = interval;
		}
	}

	public void stop(){
		this.toStop = true;
	}

	public int getInterval(){
		return this.interval;
	}

	public int getBurstAmount(){
		return this.burst;
	}

	public void setBurstAmount(int amount){
		this.burst = amount;
	}

	public enum LagMode{
		ALL = 1,
		OTHERS = 2,
		LIST = 3
	}
}


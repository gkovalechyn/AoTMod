//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.18444
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------
using GITS.Util.Json;
using Mathos.Parser;
using System.Collections.Generic;
using UnityEngine;

public class SpawnController{
	private Vector3[] spawnLocations;
	private float minSize = 0.7f;
	private float maxSize = 3f;

	private int maxAllowedTitans = 7;
	private int titansToSpawn = 0;
	private int currentTitans = 0;

    //--Wave control variables
    private int currentWave = 1;
    private int maximumWave = 20;
    //--Fixed spawn variables
    private int fixedTitanCount = 20;
    //--

	private bool useSpawnRatios = true;
    private float[] spawnProbabilities = new float[5];

	private FengGameManagerMKII gm;

	private bool isCustomRatios = false;
	private Quaternion qUp = new Quaternion(0f, 0f, 0f, 1f);
	private string titanName = "TITAN_VER3.1";

    private Dictionary<int, WaveSpawnInfo> customWaves = new Dictionary<int, WaveSpawnInfo>();
    private HashSet<int> spawnedTitansHashes = new HashSet<int>();

    public SpawnControllerMode mode = SpawnControllerMode.FIXED_SPAWN;
    private MathParser mathParser = new MathParser();
    private string titanAmountFunction = "Wave + 2";
    private string waveMessage = "<color=#FFFF00><b>Next wave: {Wave}. Titans: {TitanCount}</b></color>";

	public SpawnController(FengGameManagerMKII gm, string titanAmountFunction, string waveMessage){
		this.gm = gm;
		this.recalculateSpawnPositions();
		this.setProbabilities(new float[] { 75, 10, 5, 5, 5});

        if (!string.IsNullOrEmpty(titanAmountFunction)) {
            this.titanAmountFunction = titanAmountFunction;
        }

        this.waveMessage = waveMessage;
	}

	public void onTitanDown(TITAN t){
        if (this.spawnedTitansHashes.Contains(t.GetHashCode())) {
            this.spawnedTitansHashes.Remove(t.GetHashCode());
            this.currentTitans--;

            if (this.mode == SpawnControllerMode.WAVES && !this.customWaves.ContainsKey(this.currentWave)) {
                if (this.titansToSpawn > 0 && this.canSpawnTitans()) {
                    this.titansToSpawn -= (this.maxAllowedTitans - this.currentTitans);
                    this.spawnTitans(this.maxAllowedTitans - this.currentTitans);
                }
            }else if (this.mode == SpawnControllerMode.FIXED_SPAWN && this.titansToSpawn > 0 && this.canSpawnTitans()) {
                this.titansToSpawn -= (this.maxAllowedTitans - this.currentTitans);
                this.spawnFixedTitans(this.maxAllowedTitans - this.currentTitans);
            }

            if (this.currentTitans == 0) {
                this.handleAllTitansKilled();
            }
        }
}	

    private void handleAllTitansKilled() {
        switch (this.mode) {
            case SpawnControllerMode.FIXED_SPAWN:
                this.handleFixedSpawnEnd();
                break;
            case SpawnControllerMode.WAVES:
                this.handleWaveEnd();
                break;
            default:
                this.handleWaveEnd();
                break;
        }
    }

    private void handleFixedSpawnEnd() {
        ModMain.instance.getGameManager().photonView.RPC("Chat", PhotonTargets.All, new object[] { "<color=#FFFF00><b>All titans killed!</b></color>", string.Empty });
        ModMain.instance.getGameManager().gameWin2();
    }

    private void handleWaveEnd() {
        if (this.currentWave + 1 <= this.maximumWave) {
            this.currentWave++;
            
            if (this.customWaves.ContainsKey(this.currentWave)) {
                this.spawnCustomWaveTitans();
            } else {
                int titanAmount = 0;

                this.mathParser.LocalVariables["Wave"] = this.currentWave;
                this.mathParser.LocalVariables["PlayerCount"] = PhotonNetwork.playerList.Length;

                try {
                    titanAmount = (int)this.mathParser.Parse(this.titanAmountFunction);
                } catch (System.Exception e) {
                    ModMain.instance.log(e);
                    this.mode = SpawnControllerMode.FIXED_SPAWN;
                    ModMain.instance.sendToPlayer("Your function for the amount of titans to spawn had an error.");
                    ModMain.instance.sendToPlayer("Please make sure it is correct. Meanwhile, the mode has been set to FixedSpawns");

                    this.handleFixedSpawnEnd();
                }

                if (titanAmount > this.maxAllowedTitans) {
                    this.titansToSpawn = titanAmount - this.maxAllowedTitans;
                }

                this.spawnTitans(Mathf.Min(this.maxAllowedTitans, titanAmount));

            }

            //Send the message
            this.sendNewWaveMessage();
            //Respawn everybody except the PTs
            foreach(PhotonPlayer player in PhotonNetwork.playerList) {
                if (RCextensions.returnIntFromObject(player.customProperties[PhotonPlayerProperty.isTitan]) != 2) {
                    ModMain.instance.getGameManager().photonView.RPC("respawnHeroInNewRound", player, null);
                }
            }
        } else { //We won
            ModMain.instance.getGameManager().photonView.RPC("Chat", PhotonTargets.All, new object[] {"<color=#FFFF00><b>All waves completed!</b></color>" , string.Empty});
            ModMain.instance.getGameManager().gameWin2();
        }
    }

    private void spawnCustomWaveTitans() {
        if (this.customWaves.ContainsKey(this.currentWave)) {
            WaveSpawnInfo info = this.customWaves[this.currentWave];
            if (info.spawnByRatio) {
                for (int i = 0; i < info.amountToSpawn; i++) {
                    AbnormalType type = this.getAbnormalTypeByRatio(info.nRatio, info.aRatio, info.jRatio, info.cRatio, info.pRatio);
                    float size = UnityEngine.Random.Range(info.sizeMin, info.sizeMax); ;
                    Vector3 pos = this.spawnLocations[UnityEngine.Random.Range(0, this.spawnLocations.Length)];
                    this.spawnTitan(type, size, pos, this.qUp);
                }
            } else {
                foreach (string s in info.toSpawn) {
                    int amount = int.Parse(s.Substring(0, s.Length - 1));//This could cause an exception if the string is malformed, but fuck it
                    AbnormalType type = TitanSize.getTitanType(s[s.Length - 1]);

                    for (int i = 0; i < amount; i++) {
                        float size = UnityEngine.Random.Range(info.sizeMin, info.sizeMax); ;
                        Vector3 pos = this.spawnLocations[UnityEngine.Random.Range(0, this.spawnLocations.Length)];

                        this.spawnTitan(type, size, pos, this.qUp);
                    }
                }
            }
        }
    }

    //Spawns N-amount of titans using the custom ratios if enabled, otherwise uses feng's spawns
    private void spawnTitans(int amountToSpawn) {
        if (this.isCustomRatios) {
            for (int i = 0; i < amountToSpawn; i++) {
                AbnormalType type = this.getAbnormalTypeByRatio(this.spawnProbabilities[0], this.spawnProbabilities[1], this.spawnProbabilities[2], this.spawnProbabilities[3], this.spawnProbabilities[4]);
                float size = UnityEngine.Random.Range(this.minSize, this.maxSize);
                Vector3 pos = this.spawnLocations[UnityEngine.Random.Range(0, this.spawnLocations.Length)];

                this.spawnTitan(type, size, pos, this.qUp);
            }
        } else {
            for (int i = 0; i < amountToSpawn; i++) {
                Vector3 pos = this.spawnLocations[UnityEngine.Random.Range(0, this.spawnLocations.Length)];
                GameObject go = this.doFengSpawn(IN_GAME_MAIN_CAMERA.difficulty == 1 ? 70 : 90, pos, this.qUp, this.currentWave % 5 == 0);
                TITAN titan = go.GetComponent<TITAN>();
                ModMain.instance.getTaskManager().addLateUpdateTask(new CallRPCsTaks(titan, titan.myLevel, (int) titan.abnormalType));
            }
        }
    }

    private void spawnFixedTitans(int amountToSpawn) {
        //The fixed spawns use the same values as the wave titans, so there is no need to separate them both unless they behave differently
        //And since they both have to follow the maximum amount of titans thing we can reuse the same method aswell.
        this.spawnTitans(amountToSpawn);
    }

    //The last argument is really not needed, but better to keep it for the sake of readability
    private AbnormalType getAbnormalTypeByRatio(float nRatio, float aRatio, float jRatio, float cRatio, float pRatio) {
        float rand = UnityEngine.Random.Range(0f, 1f);
        float total = 0;
        //Basically, we have each ratio beside eachother all adding up to 1.0. Now, if the random number falls between 
        //The interval of that ratio, it is going to be that type of titan.
        if (rand >= total && rand < (total + nRatio)) {
            return AbnormalType.NORMAL;
        }
        //Adjust the total to account for the previous ratio
        total += nRatio;

        if (rand >= total && rand < (total + aRatio)) {
            return AbnormalType.TYPE_I;
        }
        total += aRatio;

        if (rand >= total && rand < (total + jRatio)) {
            return AbnormalType.TYPE_JUMPER;
        }
        total += jRatio;

        if (rand >= total && rand < (total + cRatio)) {
            return AbnormalType.TYPE_CRAWLER;
        }

        //The only one who is left is the punk
        return AbnormalType.TYPE_PUNK;
    }

    public void onLevelReload() {
        if (PhotonNetwork.isMasterClient) {
            foreach (TITAN titan in GameObject.FindObjectsOfType<TITAN>()) {
                PhotonNetwork.Destroy(titan.gameObject);
            }
        }

        this.reset();
    }
	public void onLevelLoad(){
		this.gm = ModMain.instance.getGameManager();

        this.reset();
		this.recalculateSpawnPositions();

        if (PhotonNetwork.isMasterClient) {
            this.doInitialSpawns();
        }
	}

    private void doInitialSpawns() {
        if (this.mode == SpawnControllerMode.WAVES) {
            if (this.customWaves.ContainsKey(this.currentWave)) {
                this.spawnCustomWaveTitans();
            } else {
                try {
                    int titanCount = 0;
                    this.mathParser.LocalVariables["Wave"] = this.currentWave;
                    this.mathParser.LocalVariables["PlayerCount"] = PhotonNetwork.playerList.Length;

                    titanCount = (int) this.mathParser.Parse(this.titanAmountFunction);

                    this.spawnTitans(Mathf.Min(this.maxAllowedTitans, titanCount));

                    if (titanCount > this.maxAllowedTitans) {
                        this.titansToSpawn = titanCount - this.maxAllowedTitans;
                    }
                }catch(System.Exception e) {
                    ModMain.instance.log(e);
                    this.mode = SpawnControllerMode.FIXED_SPAWN;
                    ModMain.instance.sendToPlayer("Your function for the amount of titans to spawn had an error.");
                    ModMain.instance.sendToPlayer("Please make sure it is correct. Meanwhile, the mode has been set to FixedSpawns");

                    this.doInitialSpawns();
                }
            }

            this.sendNewWaveMessage();
        } else {
            if (this.fixedTitanCount > this.maxAllowedTitans) {
                this.titansToSpawn = this.fixedTitanCount - this.maxAllowedTitans;
            }
            this.spawnFixedTitans(Mathf.Min(this.maxAllowedTitans, this.fixedTitanCount));
        }
    }
    public void reset() {
        this.currentWave = 1;
        this.spawnedTitansHashes.Clear();
        this.titansToSpawn = 0;
        this.currentTitans = 0;
    }

	public void setProbabilities(float[] arr){
		if (arr.Length == 5) {
            this.spawnProbabilities = arr;
        }
	}

	public float[] getSpawnProbabilities(){
		return this.spawnProbabilities;
	}

	public GameObject spawnTitan(AbnormalType type, float size, Vector3 pos, Quaternion rotation){
		GameObject titanPrefab = this.instantiateTitan(pos, rotation);
		TITAN_SETUP setup = titanPrefab.GetComponent<TITAN_SETUP>();
		TITAN titan = titanPrefab.GetComponent<TITAN>();

        this.currentTitans++;
        this.spawnedTitansHashes.Add(titan.GetHashCode());

        titan.resetLevel(size);

		ModMain.instance.getTaskManager().addLateUpdateTask(new CallRPCsTaks(titan, size, (int) type));
		return titanPrefab;
	}

	public void recalculateSpawnPositions(){
		GameObject[] arr = GameObject.FindGameObjectsWithTag("titanRespawn");

		this.spawnLocations = new Vector3[arr.Length];

		for(int i = 0; i < arr.Length; i++){
			this.spawnLocations[i] = arr[i].transform.position;
		}
	}

	public void setRatioEnabled(bool val){
		this.isCustomRatios = val;
	}

	public bool canSpawnTitans(){
        if (this.maxAllowedTitans > 0) {
            return this.currentTitans < this.maxAllowedTitans;
        } else {
            return true;
        }
	}

	private GameObject instantiateTitan(Vector3 pos, Quaternion rotation){
		return PhotonNetwork.Instantiate(this.titanName, pos, rotation, 0);
	}

	public int getMaxAllowedTitans(){
		return this.maxAllowedTitans;
	}

	public void setMaxAllowedTitans(int amount){
		this.maxAllowedTitans = amount;
	}

	public int getTitansToSpawn(){
		return this.titansToSpawn;
	}

	public void setTitansToSpawn(int amount){
		this.titansToSpawn = amount;
	}

	public float getMinSize(){
		return this.minSize;
	}

	public void setMinSize(float val){
		this.minSize = val;
	}

	public float getMaxSize(){
		return this.maxSize;
	}

	public void setMaxSize(float val){
		this.maxSize = val;
	}

	private GameObject doFengSpawn(int rate, Vector3 position, Quaternion rotation, bool punk){
        GameObject obj3;
        GameObject obj2 = this.spawnTitan(AbnormalType.NORMAL, UnityEngine.Random.Range(0.7f, 3f), position, rotation);
        string level = FengGameManagerMKII.level;

        if (punk) {
            obj2.GetComponent<TITAN>().setAbnormalType2(AbnormalType.TYPE_PUNK, false);
        } else if (UnityEngine.Random.Range(0, 100) < rate) {
            if (IN_GAME_MAIN_CAMERA.difficulty == 2) {
                if ((UnityEngine.Random.Range((float)0f, (float)1f) >= 0.7f) && !LevelInfo.getInfo(level).noCrawler) {
                    obj2.GetComponent<TITAN>().setAbnormalType2(AbnormalType.TYPE_CRAWLER, false);
                } else {
                    obj2.GetComponent<TITAN>().setAbnormalType2(AbnormalType.TYPE_JUMPER, false);
                }
            }
        } else if (IN_GAME_MAIN_CAMERA.difficulty == 2) {
            if ((UnityEngine.Random.Range((float)0f, (float)1f) >= 0.7f) && !LevelInfo.getInfo(level).noCrawler) {
                obj2.GetComponent<TITAN>().setAbnormalType2(AbnormalType.TYPE_CRAWLER, false);
            } else {
                obj2.GetComponent<TITAN>().setAbnormalType2(AbnormalType.TYPE_JUMPER, false);
            }
        } else if (UnityEngine.Random.Range(0, 100) < rate) {
            if ((UnityEngine.Random.Range((float)0f, (float)1f) >= 0.8f) && !LevelInfo.getInfo(level).noCrawler) {
                obj2.GetComponent<TITAN>().setAbnormalType2(AbnormalType.TYPE_CRAWLER, false);
            } else {
                obj2.GetComponent<TITAN>().setAbnormalType2(AbnormalType.TYPE_I, false);
            }
        } else if ((UnityEngine.Random.Range((float)0f, (float)1f) >= 0.8f) && !LevelInfo.getInfo(level).noCrawler) {
            obj2.GetComponent<TITAN>().setAbnormalType2(AbnormalType.TYPE_CRAWLER, false);
        } else {
            obj2.GetComponent<TITAN>().setAbnormalType2(AbnormalType.TYPE_JUMPER, false);
        }
        if (IN_GAME_MAIN_CAMERA.gametype == GAMETYPE.SINGLE) {
            obj3 = (GameObject)UnityEngine.Object.Instantiate(Resources.Load("FX/FXtitanSpawn"), obj2.transform.position, Quaternion.Euler(-90f, 0f, 0f));
        } else {
            obj3 = PhotonNetwork.Instantiate("FX/FXtitanSpawn", obj2.transform.position, Quaternion.Euler(-90f, 0f, 0f), 0);
        }
        obj3.transform.localScale = obj2.transform.localScale;

        return obj2;
    }

    private void sendNewWaveMessage() {
        ModMain.instance.getGameManager().photonView.RPC("Chat", PhotonTargets.All, new object[] {
            this.waveMessage.Replace("{Wave}", this.currentWave.ToString()).Replace("{TitanCount}", (this.currentTitans + this.titansToSpawn).ToString()), 
            string.Empty});
    }

	private class CallRPCsTaks : Task{
		private TITAN titan;
		private float size;
		private int type;

		public CallRPCsTaks(global::TITAN titan, float size, int type){
			this.titan = titan;
			this.size = size;
			this.type = type;
		}
		
		public bool execute(){
            if (titan != null && !titan.hasDie){
                
			    titan.photonView.RPC("netSetAbnormalType", PhotonTargets.AllBuffered, type);
			    titan.photonView.RPC("netSetLevel", PhotonTargets.AllBuffered, new object[] { size, IN_GAME_MAIN_CAMERA.difficulty, 1});

                if (ModMain.instance.getTHController().isEnabled()) {
                    int health = ModMain.instance.getTHController().getTitanHealth(TitanSize.getTitanType(this.type), TitanSize.getBySize(this.size));
                    titan.photonView.RPC("labelRPC", PhotonTargets.AllBuffered, health, health);
                    titan.maxHealth = titan.currentHealth = health;
                }
            }
			return true;
		}
	}

	public void setCustomWaveRatio(int wave, int titanAmount, float nr, float ar, float jr, float cr, float pr){
		WaveSpawnInfo info = new WaveSpawnInfo();
		info.amountToSpawn = titanAmount;
		info.spawnByRatio = true;

		info.nRatio = nr;
		info.aRatio = ar;
		info.jRatio = jr;
		info.cRatio = cr;
		info.pRatio = pr;

		this.customWaves[wave - 1] = info;
	}

	public void setCustomWave(int wave, int amount, params string[] titans){
		WaveSpawnInfo info = new WaveSpawnInfo();

		info.spawnByRatio = false;
		info.amountToSpawn = titans.Length;//not used
		info.toSpawn = titans;

		this.customWaves[wave - 1] = info;
	}

	public Dictionary<int, WaveSpawnInfo> getCustomWaves(){
		return this.customWaves;
	}

	public void setUseSpawnRatios(bool value){
		this.useSpawnRatios = value;
	}

	public bool isUseSpawnRatios(){
		return this.useSpawnRatios;
	}

    public SpawnControllerMode getMode() {
        return this.mode;
    }

    public void setMode(SpawnControllerMode mode) {
        this.mode = mode;

        this.reset();

        foreach(TITAN titan in GameObject.FindObjectsOfType<TITAN>()) {
            if (titan.photonView.isMine) {
                titan.photonView.RPC("netDie", PhotonTargets.AllBuffered, null);
            }
        }

        this.doInitialSpawns();
    }

    public void loadSettings(JsonObject settings) {
        JsonObject scSettings = null;

        if (settings.contains("SpawnController")) {
            scSettings = settings.getObject("SpawnController");
        } else {
            scSettings = new JsonObject();
            settings.set("SpawnController", scSettings);
        }

        if (scSettings.contains("UseSpawnRatios")){
            this.useSpawnRatios = scSettings.getBool("UseSpawnRatios");
        }

        if (scSettings.contains("SpawnRatios")) {
            JsonArray array = scSettings.getArray("SpawnRatios");
            float[] ratios = new float[5];

            if (array.size() == 5) {
                for (int i = 0; i < 5; i++) {
                    ratios[i] = ((JsonNumber)array.at(i)).getFloatValue();
                }
            }

            this.spawnProbabilities = ratios;
        }

        if (scSettings.contains("MaximumWave")) {
            this.maximumWave = scSettings.getInt("MaximumWave");
        }
        if (scSettings.contains("FixedTitanCount")) {
            this.fixedTitanCount = scSettings.getInt("FixedTitanCount");
        }
        if (scSettings.contains("MaxTitans")) {
            this.fixedTitanCount = scSettings.getInt("MaxTitans");
        }
    }

    public int getMaxWave() {
        return this.maximumWave;
    }

    public void setMaxWave(int val) {
        this.maximumWave = val;
    }

    public int getFixedSpawnCount() {
        return this.fixedTitanCount;
    }

    public void setFixedSpawnCount(int val) {
        this.fixedTitanCount = val;
    }

    public bool isCustomRatiosEnabled() {
        return this.isCustomRatios;
    }

    public void setCustomRatiosEnabled(bool val) {
        this.isCustomRatios = val;
    }

    public string getWaveFunction() {
        return this.titanAmountFunction;
    }

    public void setWaveFunction(string function) {
        this.titanAmountFunction = function;
    }

	public class WaveSpawnInfo{
		public int amountToSpawn = 3;
		public bool spawnByRatio = false;

		public float sizeMin = 0.7f;
		public float sizeMax = 3F;

		public float nRatio = 0f;
		public float aRatio = 0f;
		public float jRatio = 0f;
		public float cRatio = 0f;
		public float pRatio = 0f;

		public string[] toSpawn = new string[0];
	}
    
}


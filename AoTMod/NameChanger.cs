//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.18444
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Text;
using System.Threading;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using UnityEngine;

public class NameChanger{
	private List<string> names = new List<string>();
	private int nameIndex = 0;

	private NameMode mode = NameMode.RANDOM;

	private volatile bool toRun = false;
	private bool running = false;
	private int interval = 1000;

    private System.Random random = new System.Random((int)DateTime.Now.Ticks);

	private const string characters = "aãâáàAÁÀÃÂbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ0123456789\n\t";

	private int target = -1;
	private TaskManager taskManager;

    private string[] fadeNameParts;
    //private List<int> fadeColors = new List<int>();
    private List<Color> fadeColorClass = new List<Color>();
    private int colorSteps = 5;

    //fade bookkeping
    private StringBuilder fadeStringBuilder = new StringBuilder(128);
    private int currentColorIndex = 0;
    private int currentColorStep = 0;
    private bool invertFade = false;

    //private Regex colorPattern = new Regex("\\[[0-f\\-]{6}\\]", RegexOptions.IgnoreCase);
	public NameChanger (ModMain mod) {
		ConfigManager cfg = mod.getConfig();
		List<string> names = cfg.getStringList("NameChangerNames");

		if (names != null){
			this.names = names;
		}
	}
	
	public void start(){
		if (!this.running){
			this.taskManager = ModMain.instance.getTaskManager();
			this.toRun = true;
			new Thread(this.run).Start();
		}
	}

	public void run(){
		this.running = true;
		//ExitGames.Client.Photon.Hashtable toSet = new ExitGames.Client.Photon.Hashtable();
		try{
			while(this.toRun){
				if (PhotonNetwork.inRoom){
					//toSet[PhotonPlayerProperty.name] = this.getNextName();
					this.taskManager.addLateUpdateTask(new ChangeNameTask(this.getNextName(), this.target));
					/*
					if (this.target == -1){
						PhotonNetwork.player.SetCustomProperties(toSet);
					}else{
						PhotonPlayer target = PhotonPlayer.Find(this.target);

						if (target == null){
							this.target = -1;
						}else{
							target.SetCustomProperties(toSet);
						}
					}
					*/
				}else{
					LoginFengKAI.player.name = this.getNextName();
				}
				Thread.Sleep(this.interval);
			}
		}catch (System.Exception e){
			ModMain.instance.log(e);
		}
		this.running = false;
	}

	public enum NameMode{
		LIST = 1,
		RANDOM = 2,
		UNICODE = 3,
        FADE = 4
	}

	private string getNextName(){
		switch(this.mode){
			case NameMode.LIST:
				return this.getNextListName();
			case NameMode.RANDOM:
				return this.generateRandomName();
			case NameMode.UNICODE:
				return this.generateRandomUnicode(16);
            case NameMode.FADE:
                return this.generateFadedName();
			default:
				return "n/a";
		}
	}

	private string getNextListName(){
		string result = "n/a";

		if (this.names.Count == 0){
			return "n/a";
		}

		if (this.nameIndex >= this.names.Count){
			this.nameIndex = 0;
		}

		result = this.names[this.nameIndex];
		this.nameIndex++;

		return result;
	}

	public string generateRandomName(){
		StringBuilder stringBuilder = new StringBuilder(16);

		for (int i = 0; i < 16; i++){
			stringBuilder.Append(NameChanger.characters[this.random.Next(NameChanger.characters.Length)]);
		}

		return stringBuilder.ToString();
	}

	public string generateRandomUnicode(int length){
		byte[] str = new byte[length * 2];
		
		for (int i = 0; i < length * 2 ; i+=2){
			int chr = this.random.Next(0xD7FF);
			str[i+1] = (byte)((chr & 0xFF00) >> 8);
			str[i] = (byte)(chr & 0xFF);
		}
		
		return Encoding.Unicode.GetString(str);
	}

    public string generateFadedName() {
        if (this.fadeNameParts != null && this.fadeNameParts.Length > 0 && this.fadeColorClass.Count > 0) {
            this.fadeStringBuilder.Length = 0;
            int[] colors = this.getNextFadeColors(this.fadeNameParts.Length);

            for (int i = 0; i < this.fadeNameParts.Length; i++) {
                this.fadeStringBuilder.Append('[');

                if (this.invertFade) {
                    this.fadeStringBuilder.Append(colors[colors.Length - i - 1].ToString("X6"));
                } else {
                    this.fadeStringBuilder.Append(colors[i].ToString("X6"));
                }
                
                this.fadeStringBuilder.Append(']');
                this.fadeStringBuilder.Append(this.fadeNameParts[i]);
            }

            return this.fadeStringBuilder.ToString();
        } else {
            return "n/a";
        }
    }

    private int[] getNextFadeColors(int count) {
        //int currentColor; //= this.fadeColors[this.currentColorIndex];
        //int nextColor;
        Color currentColor;
        Color nextColor;
        int[] finalColors = new int[count];
        int tempIndex = this.currentColorIndex;
        int tempStep = this.currentColorStep;
        float percentage;

        //Basically, with the i++ it will cause that the index is incremented when it shouldn't
        for (int i = 0; i < count;) {
            currentColor = this.fadeColorClass[tempIndex];
            //percentage = tempStep / (float)this.colorSteps;
            if ((tempIndex + 1) >= this.fadeColorClass.Count) {
                nextColor = this.fadeColorClass[0];
            } else {
                nextColor = this.fadeColorClass[tempIndex + 1];
            }
            while(tempStep < this.colorSteps && i < count){
                percentage = tempStep / (float)this.colorSteps;
                Color lerped = Color.Lerp(currentColor, nextColor, percentage);
                //Color lerped = Color.Lerp(currentColor, nextColor, percentage);
                //finalColors[i] = ((int)(currentColor * (1 - percentage))) + ((int)(nextColor * percentage));
                finalColors[i] |= (((int) (lerped.r * 255)) << 16);
                finalColors[i] |= (((int)(lerped.g * 255)) << 8);
                finalColors[i] |= (((int)(lerped.b * 255)));
                tempStep++;
                i++;
            }

            //tempStep++;

            if (tempStep >= this.colorSteps) {
                tempStep = 0;
                tempIndex++;

                if (tempIndex >= this.fadeColorClass.Count) {
                    tempIndex = 0;
                }
           }

            
        }

        this.currentColorStep++;

        if (this.currentColorStep >= this.colorSteps) {
            this.currentColorStep = 0;
            this.currentColorIndex++;
        }

        if (this.currentColorIndex >= this.fadeColorClass.Count) {
            this.currentColorIndex = 0;
        }

        return finalColors;
    }
    public void setInvertFade(bool value) {
        this.invertFade = value;
    }
    public void setFadeColors(List<int> colors) {
        foreach (int i in colors) {
            float r = ((i >> 16) & 0xFF) / 255f;
            float g = ((i >> 8) & 0xFF) / 255f;
            float b = ((i) & 0xFF) / 255f;
            this.fadeColorClass.Add(new Color(r, g, b, 1f));
        }
    }

    public void setStepCount(int i) {
        this.colorSteps = i;
    }

    public List<int> getFadeColors() {
        List<int> result = new List<int>();

        foreach (Color col in this.fadeColorClass) {
            int i = 0;
            i |= ((int)(col.r * 255f)) << 16;
            i |= ((int)(col.g * 255f)) << 8;
            i |= ((int)(col.b * 255f));
            result.Add(i);
        }

        return result;
    }

    public int getStepCount() {
        return this.colorSteps;
    }

	public List<string> getNames(){
		return this.names;
	}

	public void setInterval(int value){
		this.interval = value;
	}

	public long getInterval(){
		return this.interval;
	}

	public void setMode(NameMode mode){
		this.mode = mode;
        if (mode == NameMode.FADE) {
            string nameToUse;
            this.currentColorIndex = 0;
            this.currentColorStep = 0;

            if (this.target > 0) {
                PhotonPlayer player = PhotonPlayer.Find(this.target);

                if (player != null && player.customProperties[PhotonPlayerProperty.name] != null) {
                    nameToUse = ModMain.stripColorCodes((string)player.customProperties[PhotonPlayerProperty.name]);
                } else {
                    nameToUse = ModMain.stripColorCodes((string)PhotonNetwork.player.customProperties[PhotonPlayerProperty.name]);
                }
            } else {
                nameToUse = ModMain.stripColorCodes((string)PhotonNetwork.player.customProperties[PhotonPlayerProperty.name]);
            }

            char[] temp = nameToUse.ToCharArray();
            string[] temp2 = new string[temp.Length];
            for (int i = 0; i < temp.Length; i++) {
                temp2[i] = "" + temp[i];
            }

            this.fadeNameParts = temp2;
        }
	}

	public NameMode getMode(){
		return this.mode;
	}

	public void stop(){
		this.toRun = false;
	}

	public void addName(string name){
		this.names.Add(name);
	}

	public void removeName(int index){
		this.names.RemoveAt(index);
	}

	public bool isRunning(){
		return this.running;
	}

	public void setTarget(int id){
		this.target = id;
	}

	private class ChangeNameTask : Task{
		private readonly string name;
		private readonly int target;

		public ChangeNameTask (string name, int target) {
			this.name = name;
			this.target = target;
		}
		
		public bool execute (){
			ExitGames.Client.Photon.Hashtable toSet = new ExitGames.Client.Photon.Hashtable();
			toSet[PhotonPlayerProperty.name] = name;

			if (this.target == -1){
				PhotonNetwork.player.SetCustomProperties(toSet);
                ModMain.instance.getModMainThread().updateInternalPlayerProperties();
			}else{
				PhotonPlayer target = PhotonPlayer.Find(this.target);
				
				if (target == null){
					ModMain.instance.getNameChanger().stop();
				}else{
					target.SetCustomProperties(toSet);
				}
			}

			return true;
		}
	}
}

